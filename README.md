- run.py initializes the flask app and provides the context for it to run
- poetry new is used to create the folder structure initially and is then used to manage the dependencies
- requirements.txt is created as part of a pre-commit hook so that Docker can reconstruct the project dependencies with pip instead of having to bring in poetry during the build
- poetry is also used to provide a local virtual environment for testing
- The .gitignore keeps unnecessary Flask, pytest, VScode and Javascript build artifacts out of the repository
- Most of the project itself is held inside the directory of the same name as the repository; there we have folders for:
  - static (contains all static files (.css and image files) as well as our Javascript + React + Typescript files)
  - templates (holds all the jinja files for different routes)
- In this folder the main files for running the app are available as well
  - app.py creates the Flask application and loads any context for the application (Blueprints, database connections, testing configurations, application configuration, etc)
  - db.py creates the connection to the database we're currently working with
  - model.py defines the database schema
  - [pakage].py is for the main application logic/routes
- CI/CD is handled by GitHub Actions in the .github folder
- The project is deployed to Google Cloud Run and run in a container. The Dockerfile defines the build process and compilation of that container.
- The Dockerfile runs through building the JS assets and then passing them off to the Python runtime where we put the assets in the right location in the Flask app also install all of the required Python packages for the project
- The Docker container is built inside of a GitHub Action (see .github/workflows/deploy.yml) and pushed to a Google Cloud project's artifact registry and then loaded into the cloud run service
- Secrets are added as needed per https://github.com/google-github-actions/auth?tab=readme-ov-file#indirect-wif
